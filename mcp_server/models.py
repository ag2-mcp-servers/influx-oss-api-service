# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T03:45:53+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Literal, Optional, Union

from pydantic import (
    AnyUrl,
    BaseModel,
    ConfigDict,
    Field,
    RootModel,
    confloat,
    conint,
    constr,
)


class AddResourceMemberRequestBody(BaseModel):
    id: str
    name: Optional[str] = None


class Error(BaseModel):
    character: Optional[int] = None
    column: Optional[int] = None
    line: Optional[int] = None
    message: Optional[str] = None


class AnalyzeQueryResponse(BaseModel):
    errors: Optional[List[Error]] = None


class Status(Enum):
    active = 'active'
    inactive = 'inactive'


class AuthorizationUpdateRequest(BaseModel):
    description: Optional[str] = Field(None, description='A description of the token.')
    status: Optional[Status] = Field(
        'active',
        description='If inactive the token is inactive and requests using the token will be rejected.',
    )


class Base(Enum):
    field_ = ''
    field_2 = '2'
    field_10 = '10'


class AxisScale(Enum):
    log = 'log'
    linear = 'linear'


class HoverDimension(Enum):
    auto = 'auto'
    x = 'x'
    y = 'y'
    xy = 'xy'


class Shape(Enum):
    chronograf_v2 = 'chronograf-v2'


class Type(Enum):
    band = 'band'


class Type1(Enum):
    user = 'user'
    system = 'system'


class BuilderAggregateFunctionType(Enum):
    filter = 'filter'
    group = 'group'


class AggregateWindow(BaseModel):
    fillValues: Optional[bool] = None
    period: Optional[str] = None


class BuilderFunctionsType(BaseModel):
    name: Optional[str] = None


class BuilderTagsType(BaseModel):
    aggregateFunctionType: Optional[BuilderAggregateFunctionType] = None
    key: Optional[str] = None
    values: Optional[List[str]] = None


class Links2(BaseModel):
    self: Optional[str] = None
    view: Optional[str] = None


class Cell(BaseModel):
    h: Optional[int] = None
    id: Optional[str] = None
    links: Optional[Links2] = None
    viewID: Optional[str] = Field(
        None, description='The reference to a view from the views API.'
    )
    w: Optional[int] = None
    x: Optional[int] = None
    y: Optional[int] = None


class CellUpdate(BaseModel):
    h: Optional[int] = None
    w: Optional[int] = None
    x: Optional[int] = None
    y: Optional[int] = None


class Cells(RootModel[List[Cell]]):
    root: List[Cell]


class LastRunStatus(Enum):
    failed = 'failed'
    success = 'success'
    canceled = 'canceled'


class CheckPatch(BaseModel):
    description: Optional[str] = None
    name: Optional[str] = None
    status: Optional[Status] = 'active'


class CheckStatusLevel(Enum):
    UNKNOWN = 'UNKNOWN'
    OK = 'OK'
    INFO = 'INFO'
    CRIT = 'CRIT'
    WARN = 'WARN'


class Type2(Enum):
    check = 'check'


class Type3(Enum):
    constant = 'constant'


class ConstantVariableProperties(BaseModel):
    type: Optional[Type3] = None
    values: Optional[List[str]] = None


class CreateCell(BaseModel):
    h: Optional[int] = None
    name: Optional[str] = None
    usingView: Optional[str] = Field(
        None, description='Makes a copy of the provided view.'
    )
    w: Optional[int] = None
    x: Optional[int] = None
    y: Optional[int] = None


class CreateDashboardRequest(BaseModel):
    description: Optional[str] = Field(
        None, description='The user-facing description of the dashboard.'
    )
    name: str = Field(..., description='The user-facing name of the dashboard.')
    orgID: str = Field(
        ..., description='The ID of the organization that owns the dashboard.'
    )


class Type4(Enum):
    custom = 'custom'


class Meta(BaseModel):
    createdAt: Optional[datetime] = None
    updatedAt: Optional[datetime] = None


class Type5(Enum):
    min = 'min'
    max = 'max'
    threshold = 'threshold'
    scale = 'scale'
    text = 'text'
    background = 'background'


class DashboardColor(BaseModel):
    hex: constr(min_length=7, max_length=7) = Field(
        ..., description='The hex number of the color'
    )
    id: str = Field(..., description='The unique ID of the view color.')
    name: str = Field(..., description='The user-facing name of the hex color.')
    type: Type5 = Field(..., description='Type is how the color is used.')
    value: float = Field(..., description='The data value mapped to this color.')


class Tag(BaseModel):
    key: Optional[str] = None
    value: Optional[str] = None


class Type6(Enum):
    deadman = 'deadman'


class DecimalPlaces(BaseModel):
    digits: Optional[int] = Field(
        None, description='The number of digits after decimal to display'
    )
    isEnforced: Optional[bool] = Field(
        None, description='Indicates whether decimal point setting should be enforced'
    )


class DeletePredicateRequest(BaseModel):
    predicate: Optional[str] = Field(
        None,
        description='InfluxQL-like delete statement',
        examples=['tag1="value1" and (tag2="value2" and tag3!="value3")'],
    )
    start: datetime = Field(..., description='RFC3339Nano')
    stop: datetime = Field(..., description='RFC3339Nano')


class Annotation(Enum):
    group = 'group'
    datatype = 'datatype'
    default = 'default'


class DateTimeFormat(Enum):
    RFC3339 = 'RFC3339'
    RFC3339Nano = 'RFC3339Nano'


class Dialect(BaseModel):
    annotations: Optional[List[Annotation]] = Field(
        None,
        description='https://www.w3.org/TR/2015/REC-tabular-data-model-20151217/#columns',
    )
    commentPrefix: Optional[constr(min_length=0, max_length=1)] = Field(
        '#', description='Character prefixed to comment strings'
    )
    dateTimeFormat: Optional[DateTimeFormat] = Field(
        'RFC3339', description='Format of timestamps'
    )
    delimiter: Optional[constr(min_length=1, max_length=1)] = Field(
        ',', description='Separator between cells; the default is ,'
    )
    header: Optional[bool] = Field(
        True, description='If true, the results will contain a header row'
    )


class DocumentMeta(BaseModel):
    createdAt: Optional[datetime] = None
    description: Optional[str] = None
    name: str
    templateID: Optional[str] = None
    type: Optional[str] = None
    updatedAt: Optional[datetime] = None
    version: str


class DocumentUpdate(BaseModel):
    content: Optional[Dict[str, Any]] = None
    meta: Optional[DocumentMeta] = None


class Code(Enum):
    internal_error = 'internal error'
    not_found = 'not found'
    conflict = 'conflict'
    invalid = 'invalid'
    unprocessable_entity = 'unprocessable entity'
    empty_value = 'empty value'
    unavailable = 'unavailable'
    forbidden = 'forbidden'
    too_many_requests = 'too many requests'
    unauthorized = 'unauthorized'
    method_not_allowed = 'method not allowed'
    request_too_large = 'request too large'
    unsupported_media_type = 'unsupported media type'


class Error1(BaseModel):
    code: Code = Field(..., description='code is the machine-readable error code.')
    err: Optional[str] = Field(
        None,
        description='err is a stack of errors that occurred during processing of the request. Useful for debugging.',
    )
    message: str = Field(..., description='message is a human-readable message.')
    op: Optional[str] = Field(
        None,
        description='op describes the logical code operation during error. Useful for debugging.',
    )


class Type7(Enum):
    func = 'func'
    field = 'field'
    integer = 'integer'
    number = 'number'
    regex = 'regex'
    wildcard = 'wildcard'


class FieldModel(BaseModel):
    alias: Optional[str] = Field(
        None,
        description='Alias overrides the field name in the returned response.  Applies only if type is `func`',
    )
    args: Optional[List[FieldModel]] = Field(
        None, description='Args are the arguments to the function'
    )
    type: Optional[Type7] = Field(
        None,
        description='`type` describes the field type. `func` is a function. `field` is a field reference.',
    )
    value: Optional[str] = Field(
        None,
        description='value is the value of the field.  Meaning of the value is implied by the `type` key',
    )


class Flags(BaseModel):
    pass
    model_config = ConfigDict(
        extra='allow',
    )


class FluxResponse(BaseModel):
    flux: Optional[str] = None


class FluxSuggestion(BaseModel):
    name: Optional[str] = None
    params: Optional[Dict[str, str]] = None


class FluxSuggestions(BaseModel):
    funcs: Optional[List[FluxSuggestion]] = None


class Type8(Enum):
    gauge = 'gauge'


class Type9(Enum):
    heatmap = 'heatmap'
    circleMap = 'circleMap'
    pointMap = 'pointMap'
    trackMap = 'trackMap'


class GeoViewLayerProperties(BaseModel):
    type: Type9


class Center(BaseModel):
    lat: float = Field(..., description='Latitude of the center of the map')
    lon: float = Field(..., description='Longitude of the center of the map')


class Type10(Enum):
    geo = 'geo'


class Type11(Enum):
    greater = 'greater'


class AuthMethod(Enum):
    none = 'none'
    basic = 'basic'
    bearer = 'bearer'


class Method(Enum):
    POST = 'POST'
    GET = 'GET'
    PUT = 'PUT'


class Type12(Enum):
    http = 'http'


class HTTPNotificationRuleBase(BaseModel):
    type: Type12
    url: Optional[str] = None


class Status2(Enum):
    pass_ = 'pass'
    fail = 'fail'


class HealthCheck(BaseModel):
    checks: Optional[List[HealthCheck]] = None
    commit: Optional[str] = None
    message: Optional[str] = None
    name: str
    status: Status2
    version: Optional[str] = None


class Type13(Enum):
    heatmap = 'heatmap'


class Position(Enum):
    overlaid = 'overlaid'
    stacked = 'stacked'


class Type14(Enum):
    histogram = 'histogram'


class Type15(Enum):
    influxql = 'influxql'


class InfluxQLQuery(BaseModel):
    bucket: Optional[str] = Field(
        None,
        description='Bucket is to be used instead of the database and retention policy specified in the InfluxQL query.',
    )
    query: str = Field(..., description='InfluxQL query execute.')
    type: Optional[Type15] = Field(
        None, description='The type of query. Must be "influxql".'
    )


class IsOnboarding(BaseModel):
    allowed: Optional[bool] = Field(
        None,
        description='True means that the influxdb instance has NOT had initial setup; false means that the database has been setup.',
    )


class Label(BaseModel):
    id: Optional[str] = None
    name: Optional[str] = None
    orgID: Optional[str] = None
    properties: Optional[Dict[str, str]] = Field(
        None,
        description='Key/Value pairs associated with this label. Keys can be removed by sending an update with an empty value.',
        examples=[{'color': 'ffb3b3', 'description': 'this is a description'}],
    )


class LabelCreateRequest(BaseModel):
    name: str
    orgID: str
    properties: Optional[Dict[str, str]] = Field(
        None,
        description='Key/Value pairs associated with this label. Keys can be removed by sending an update with an empty value.',
        examples=[{'color': 'ffb3b3', 'description': 'this is a description'}],
    )


class LabelMapping(BaseModel):
    labelID: Optional[str] = None


class LabelUpdate(BaseModel):
    name: Optional[str] = None
    properties: Optional[Dict[str, str]] = Field(
        None,
        description='Key/Value pairs associated with this label. Keys can be removed by sending an update with an empty value.',
        examples=[{'color': 'ffb3b3', 'description': 'this is a description'}],
    )


class Labels(RootModel[List[Label]]):
    root: List[Label]


class LanguageRequest(BaseModel):
    query: str = Field(..., description='Flux query script to be analyzed')


class Type16(Enum):
    lesser = 'lesser'


class Type17(Enum):
    line_plus_single_stat = 'line-plus-single-stat'


class Code1(Enum):
    internal_error = 'internal error'
    not_found = 'not found'
    conflict = 'conflict'
    invalid = 'invalid'
    empty_value = 'empty value'
    unavailable = 'unavailable'


class LineProtocolError(BaseModel):
    code: Code1 = Field(..., description='Code is the machine-readable error code.')
    err: str = Field(
        ...,
        description='Err is a stack of errors that occurred during processing of the request. Useful for debugging.',
    )
    line: Optional[int] = Field(
        None, description='First line within sent body containing malformed data'
    )
    message: str = Field(..., description='Message is a human-readable message.')
    op: str = Field(
        ...,
        description='Op describes the logical code operation during error. Useful for debugging.',
    )


class Code2(Enum):
    invalid = 'invalid'


class LineProtocolLengthError(BaseModel):
    code: Code2 = Field(..., description='Code is the machine-readable error code.')
    maxLength: int = Field(
        ..., description='Max length in bytes for a body of line-protocol.'
    )
    message: str = Field(..., description='Message is a human-readable message.')


class Link(RootModel[AnyUrl]):
    root: AnyUrl = Field(..., description='URI of resource.')


class Links(BaseModel):
    next: Optional[Link] = None
    prev: Optional[Link] = None
    self: Link


class LogEvent(BaseModel):
    message: Optional[str] = Field(
        None,
        description='A description of the event that occurred.',
        examples=['Halt and catch fire'],
    )
    runID: Optional[str] = Field(None, description='the ID of the task that logged')
    time: Optional[datetime] = Field(
        None, description='Time event occurred, RFC3339Nano.'
    )


class Logs(BaseModel):
    events: Optional[List[LogEvent]] = None


class Type18(Enum):
    map = 'map'


class MapVariableProperties(BaseModel):
    type: Optional[Type18] = None
    values: Optional[Dict[str, str]] = None


class Type19(Enum):
    markdown = 'markdown'


class MarkdownViewProperties(BaseModel):
    note: str
    shape: Shape
    type: Type19


class Type20(Enum):
    mosaic = 'mosaic'


class NodeType(RootModel[str]):
    root: str = Field(..., description='Type of AST node')


class Links8(BaseModel):
    labels: Optional[Link] = Field(
        None, description='URL to retrieve labels for this endpoint.'
    )
    members: Optional[Link] = Field(
        None, description='URL to retrieve members for this endpoint.'
    )
    owners: Optional[Link] = Field(
        None, description='URL to retrieve owners for this endpoint.'
    )
    self: Optional[Link] = Field(None, description='URL for this endpoint.')


class Status3(Enum):
    active = 'active'
    inactive = 'inactive'


class NotificationEndpointType(Enum):
    slack = 'slack'
    pagerduty = 'pagerduty'
    http = 'http'
    telegram = 'telegram'


class NotificationEndpointUpdate(BaseModel):
    description: Optional[str] = None
    name: Optional[str] = None
    status: Optional[Status3] = 'active'


class Links9(BaseModel):
    labels: Optional[Link] = Field(
        None, description='URL to retrieve labels for this notification rule.'
    )
    members: Optional[Link] = Field(
        None, description='URL to retrieve members for this notification rule.'
    )
    owners: Optional[Link] = Field(
        None, description='URL to retrieve owners for this notification rule.'
    )
    query: Optional[Link] = Field(
        None, description='URL to retrieve flux script for this notification rule.'
    )
    self: Optional[Link] = Field(None, description='URL for this endpoint.')


class NotificationRuleUpdate(BaseModel):
    description: Optional[str] = None
    name: Optional[str] = None
    status: Optional[Status3] = 'active'


class OnboardingRequest(BaseModel):
    bucket: str
    org: str
    password: Optional[str] = None
    retentionPeriodHrs: Optional[int] = Field(
        None,
        description="Retention period *in nanoseconds* for the new bucket. This key's name has been misleading since OSS 2.0 GA, please transition to use `retentionPeriodSeconds`\n",
    )
    retentionPeriodSeconds: Optional[int] = None
    token: Optional[str] = Field(
        None,
        description='Authentication token to set on the initial user. If not specified, the server will generate a token.\n',
    )
    username: str


class Links10(BaseModel):
    buckets: Optional[Link] = None
    dashboards: Optional[Link] = None
    labels: Optional[Link] = None
    members: Optional[Link] = None
    owners: Optional[Link] = None
    secrets: Optional[Link] = None
    self: Optional[Link] = None
    tasks: Optional[Link] = None


class Organization(BaseModel):
    createdAt: Optional[datetime] = None
    description: Optional[str] = None
    id: Optional[str] = None
    links: Optional[Links10] = Field(
        None,
        examples=[
            {
                'buckets': '/api/v2/buckets?org=myorg',
                'dashboards': '/api/v2/dashboards?org=myorg',
                'labels': '/api/v2/orgs/1/labels',
                'members': '/api/v2/orgs/1/members',
                'owners': '/api/v2/orgs/1/owners',
                'secrets': '/api/v2/orgs/1/secrets',
                'self': '/api/v2/orgs/1',
                'tasks': '/api/v2/tasks?org=myorg',
            }
        ],
    )
    name: str
    status: Optional[Status3] = Field(
        'active', description='If inactive the organization is inactive.'
    )
    updatedAt: Optional[datetime] = None


class Organizations(BaseModel):
    links: Optional[Links] = None
    orgs: Optional[List[Organization]] = None


class Type21(Enum):
    pagerduty = 'pagerduty'


class PagerDutyNotificationRuleBase(BaseModel):
    messageTemplate: str
    type: Type21


class PasswordResetBody(BaseModel):
    password: str


class PatchOrganizationRequest(BaseModel):
    description: Optional[str] = Field(
        None, description='New description to set on the organization'
    )
    name: Optional[str] = Field(None, description='New name to set on the organization')


class Type22(Enum):
    expire = 'expire'


class PatchRetentionRule(BaseModel):
    everySeconds: Optional[conint(ge=0)] = Field(
        None,
        description='Duration in seconds for how long data will be kept in the database. 0 means infinite.',
        examples=[86400],
    )
    shardGroupDurationSeconds: Optional[int] = Field(
        None, description='Shard duration measured in seconds.'
    )
    type: Type22


class PatchRetentionRules(RootModel[List[PatchRetentionRule]]):
    root: List[PatchRetentionRule] = Field(
        ...,
        description='Updates to rules to expire or retain data. No rules means no updates.',
    )


class Action(Enum):
    read = 'read'
    write = 'write'


class PipeLiteral(BaseModel):
    type: Optional[NodeType] = None


class PostOrganizationRequest(BaseModel):
    description: Optional[str] = None
    name: str


class Type23(Enum):
    flux = 'flux'


class QueryEditMode(Enum):
    builder = 'builder'
    advanced = 'advanced'


class Type24(Enum):
    query = 'query'


class Values(BaseModel):
    language: Optional[str] = None
    query: Optional[str] = None


class QueryVariableProperties(BaseModel):
    type: Optional[Type24] = None
    values: Optional[Values] = None


class Type25(Enum):
    range = 'range'


class Status7(Enum):
    ready = 'ready'


class Ready(BaseModel):
    started: Optional[datetime] = Field(
        None, examples=['2019-03-13T10:09:33.891196-04:00']
    )
    status: Optional[Status7] = None
    up: Optional[str] = Field(None, examples=['14m45.911966424s'])


class RegexpLiteral(BaseModel):
    type: Optional[NodeType] = None
    value: Optional[str] = None


class RenamableField(BaseModel):
    displayName: Optional[str] = Field(
        None, description='The name that a field is renamed to by the user.'
    )
    internalName: Optional[str] = Field(
        None, description='The calculated name of a field.'
    )
    visible: Optional[bool] = Field(
        None, description='Indicates whether this field should be visible on the table.'
    )


class Type26(Enum):
    authorizations = 'authorizations'
    buckets = 'buckets'
    dashboards = 'dashboards'
    orgs = 'orgs'
    sources = 'sources'
    tasks = 'tasks'
    telegrafs = 'telegrafs'
    users = 'users'
    variables = 'variables'
    scrapers = 'scrapers'
    secrets = 'secrets'
    labels = 'labels'
    views = 'views'
    documents = 'documents'
    notificationRules = 'notificationRules'
    notificationEndpoints = 'notificationEndpoints'
    checks = 'checks'
    dbrp = 'dbrp'
    notebooks = 'notebooks'


class Resource(BaseModel):
    id: Optional[str] = Field(
        None,
        description='If ID is set that is a permission for a specific resource. if it is not set it is a permission for all resources of that resource type.',
    )
    name: Optional[str] = Field(
        None,
        description='Optional name of the resource if the resource has a name field.',
    )
    org: Optional[str] = Field(
        None,
        description='Optional name of the organization of the organization with orgID.',
    )
    orgID: Optional[str] = Field(
        None,
        description='If orgID is set that is a permission for all resources owned my that org. if it is not set it is a permission for all resources of that resource type.',
    )
    type: Type26


class Role(Enum):
    member = 'member'


class Links11(BaseModel):
    self: Optional[AnyUrl] = None


class Role1(Enum):
    owner = 'owner'


class Type27(Enum):
    expire = 'expire'


class RetentionRule(BaseModel):
    everySeconds: conint(ge=0) = Field(
        ...,
        description='Duration in seconds for how long data will be kept in the database. 0 means infinite.',
        examples=[86400],
    )
    shardGroupDurationSeconds: Optional[int] = Field(
        None, description='Shard duration measured in seconds.'
    )
    type: Type27


class RetentionRules(RootModel[List[RetentionRule]]):
    root: List[RetentionRule] = Field(
        ...,
        description='Rules to expire or retain data.  No rules means data never expires.',
    )


class External(BaseModel):
    statusFeed: Optional[AnyUrl] = None


class Query1(BaseModel):
    analyze: Optional[AnyUrl] = None
    ast: Optional[AnyUrl] = None
    self: Optional[AnyUrl] = None
    suggestions: Optional[AnyUrl] = None


class System(BaseModel):
    debug: Optional[AnyUrl] = None
    health: Optional[AnyUrl] = None
    metrics: Optional[AnyUrl] = None


class Routes(BaseModel):
    authorizations: Optional[AnyUrl] = None
    buckets: Optional[AnyUrl] = None
    dashboards: Optional[AnyUrl] = None
    external: Optional[External] = None
    flags: Optional[AnyUrl] = None
    me: Optional[AnyUrl] = None
    orgs: Optional[AnyUrl] = None
    query: Optional[Query1] = None
    setup: Optional[AnyUrl] = None
    signin: Optional[AnyUrl] = None
    signout: Optional[AnyUrl] = None
    sources: Optional[AnyUrl] = None
    system: Optional[System] = None
    tasks: Optional[AnyUrl] = None
    telegrafs: Optional[AnyUrl] = None
    users: Optional[AnyUrl] = None
    variables: Optional[AnyUrl] = None
    write: Optional[AnyUrl] = None


class RuleStatusLevel(Enum):
    UNKNOWN = 'UNKNOWN'
    OK = 'OK'
    INFO = 'INFO'
    CRIT = 'CRIT'
    WARN = 'WARN'
    ANY = 'ANY'


class Links13(BaseModel):
    retry: Optional[AnyUrl] = None
    self: Optional[AnyUrl] = None
    task: Optional[AnyUrl] = None


class Status8(Enum):
    scheduled = 'scheduled'
    started = 'started'
    failed = 'failed'
    success = 'success'
    canceled = 'canceled'


class Run(BaseModel):
    finishedAt: Optional[datetime] = Field(
        None, description='Time run finished executing, RFC3339Nano.'
    )
    id: Optional[str] = None
    links: Optional[Links13] = Field(
        None,
        examples=[
            {
                'retry': '/api/v2/tasks/1/runs/1/retry',
                'self': '/api/v2/tasks/1/runs/1',
                'task': '/api/v2/tasks/1',
            }
        ],
    )
    log: Optional[List[LogEvent]] = Field(
        None, description='An array of logs associated with the run.'
    )
    requestedAt: Optional[datetime] = Field(
        None, description='Time run was manually requested, RFC3339Nano.'
    )
    scheduledFor: Optional[datetime] = Field(
        None, description='Time used for run\'s "now" option, RFC3339.'
    )
    startedAt: Optional[datetime] = Field(
        None, description='Time run started executing, RFC3339Nano.'
    )
    status: Optional[Status8] = None
    taskID: Optional[str] = None


class RunManually(BaseModel):
    scheduledFor: Optional[datetime] = Field(
        None,
        description='Time used for run\'s "now" option, RFC3339.  Default is the server\'s now time.',
    )


class Runs(BaseModel):
    links: Optional[Links] = None
    runs: Optional[List[Run]] = None


class Type28(Enum):
    smtp = 'smtp'


class SMTPNotificationRuleBase(BaseModel):
    bodyTemplate: Optional[str] = None
    subjectTemplate: str
    to: str
    type: Type28


class Type29(Enum):
    scatter = 'scatter'


class SchemaType(Enum):
    implicit = 'implicit'
    explicit = 'explicit'


class Type30(Enum):
    prometheus = 'prometheus'


class ScraperTargetRequest(BaseModel):
    allowInsecure: Optional[bool] = Field(
        False, description='Skip TLS verification on endpoint.'
    )
    bucketID: Optional[str] = Field(
        None, description='The ID of the bucket to write to.'
    )
    name: Optional[str] = Field(None, description='The name of the scraper target.')
    orgID: Optional[str] = Field(None, description='The organization ID.')
    type: Optional[Type30] = Field(
        None, description='The type of the metrics to be parsed.'
    )
    url: Optional[str] = Field(
        None,
        description='The URL of the metrics endpoint.',
        examples=['http://localhost:9090/metrics'],
    )


class Links14(BaseModel):
    bucket: Optional[Link] = None
    members: Optional[Link] = None
    organization: Optional[Link] = None
    owners: Optional[Link] = None
    self: Optional[Link] = None


class ScraperTargetResponse(ScraperTargetRequest):
    bucket: Optional[str] = Field(None, description='The bucket name.')
    id: Optional[str] = None
    links: Optional[Links14] = Field(
        None,
        examples=[
            {
                'bucket': '/api/v2/buckets/1',
                'members': '/api/v2/scrapers/1/members',
                'organization': '/api/v2/orgs/1',
                'owners': '/api/v2/scrapers/1/owners',
                'self': '/api/v2/scrapers/1',
            }
        ],
    )
    org: Optional[str] = Field(None, description='The name of the organization.')


class ScraperTargetResponses(BaseModel):
    configurations: Optional[List[ScraperTargetResponse]] = None


class SecretKeys(BaseModel):
    secrets: Optional[List[str]] = None


class Links15(BaseModel):
    org: Optional[str] = None
    self: Optional[str] = None


class SecretKeysResponse(SecretKeys):
    links: Optional[Links15] = None


class Secrets(RootModel[Any]):
    root: Any = Field(..., examples=[{'apikey': 'abc123xyz'}])


class Type31(Enum):
    single_stat = 'single-stat'


class Type32(Enum):
    slack = 'slack'


class SlackNotificationRuleBase(BaseModel):
    channel: Optional[str] = None
    messageTemplate: str
    type: Type32


class Language(Enum):
    flux = 'flux'
    influxql = 'influxql'


class Links16(BaseModel):
    buckets: Optional[str] = None
    health: Optional[str] = None
    query: Optional[str] = None
    self: Optional[str] = None


class Type33(Enum):
    v1 = 'v1'
    v2 = 'v2'
    self = 'self'


class Source(BaseModel):
    default: Optional[bool] = None
    defaultRP: Optional[str] = None
    id: Optional[str] = None
    insecureSkipVerify: Optional[bool] = None
    languages: Optional[List[Language]] = None
    links: Optional[Links16] = None
    metaUrl: Optional[AnyUrl] = None
    name: Optional[str] = None
    orgID: Optional[str] = None
    password: Optional[str] = None
    sharedSecret: Optional[str] = None
    telegraf: Optional[str] = None
    token: Optional[str] = None
    type: Optional[Type33] = None
    url: Optional[AnyUrl] = None
    username: Optional[str] = None


class Links17(BaseModel):
    self: Optional[AnyUrl] = None


class Sources(BaseModel):
    links: Optional[Links17] = None
    sources: Optional[List[Source]] = None


class Links18(BaseModel):
    self: Optional[str] = None


class StaticLegend(BaseModel):
    colorizeRows: Optional[bool] = None
    heightRatio: Optional[float] = None
    hide: Optional[bool] = None
    opacity: Optional[float] = None
    orientationThreshold: Optional[int] = None
    valueAxis: Optional[str] = None
    widthRatio: Optional[float] = None


class StatusRule(BaseModel):
    count: Optional[int] = None
    currentLevel: Optional[RuleStatusLevel] = None
    period: Optional[str] = None
    previousLevel: Optional[RuleStatusLevel] = None


class StringLiteral(BaseModel):
    type: Optional[NodeType] = None
    value: Optional[str] = None


class Wrapping(Enum):
    truncate = 'truncate'
    wrap = 'wrap'
    single_line = 'single-line'


class TableOptions(BaseModel):
    fixFirstColumn: Optional[bool] = Field(
        None,
        description='fixFirstColumn indicates whether the first column of the table should be locked',
    )
    sortBy: Optional[RenamableField] = None
    verticalTimeAxis: Optional[bool] = Field(
        None,
        description='verticalTimeAxis describes the orientation of the table by indicating whether the time axis will be displayed vertically',
    )
    wrapping: Optional[Wrapping] = Field(
        None,
        description='Wrapping describes the text wrapping style to be used in table views',
    )


class Type34(Enum):
    table = 'table'


class Operator(Enum):
    equal = 'equal'
    notequal = 'notequal'
    equalregex = 'equalregex'
    notequalregex = 'notequalregex'


class TagRule(BaseModel):
    key: Optional[str] = None
    operator: Optional[Operator] = None
    value: Optional[str] = None


class Links19(BaseModel):
    labels: Optional[Link] = None
    logs: Optional[Link] = None
    members: Optional[Link] = None
    owners: Optional[Link] = None
    runs: Optional[Link] = None
    self: Optional[Link] = None


class TaskStatusType(Enum):
    active = 'active'
    inactive = 'inactive'


class TaskUpdateRequest(BaseModel):
    cron: Optional[str] = Field(
        None, description="Override the 'cron' option in the flux script."
    )
    description: Optional[str] = Field(
        None, description='An optional description of the task.'
    )
    every: Optional[str] = Field(
        None, description="Override the 'every' option in the flux script."
    )
    flux: Optional[str] = Field(
        None, description='The Flux script to run for this task.'
    )
    name: Optional[str] = Field(
        None, description="Override the 'name' option in the flux script."
    )
    offset: Optional[str] = Field(
        None, description="Override the 'offset' option in the flux script."
    )
    status: Optional[TaskStatusType] = None


class Links20(BaseModel):
    labels: Optional[Link] = None
    members: Optional[Link] = None
    owners: Optional[Link] = None
    self: Optional[Link] = None


class TelegrafPlugin(BaseModel):
    config: Optional[str] = None
    description: Optional[str] = None
    name: Optional[str] = None
    type: Optional[str] = None


class TelegrafPlugins(BaseModel):
    os: Optional[str] = None
    plugins: Optional[List[TelegrafPlugin]] = None
    version: Optional[str] = None


class Metadata(BaseModel):
    buckets: Optional[List[str]] = None


class TelegrafRequest(BaseModel):
    config: Optional[str] = None
    description: Optional[str] = None
    metadata: Optional[Metadata] = None
    name: Optional[str] = None
    orgID: Optional[str] = None


class ParseMode(Enum):
    MarkdownV2 = 'MarkdownV2'
    HTML = 'HTML'
    Markdown = 'Markdown'


class Type35(Enum):
    telegram = 'telegram'


class TelegramNotificationRuleBase(BaseModel):
    disableWebPagePreview: Optional[bool] = Field(
        None,
        description='Disables preview of web links in the sent messages when "true". Defaults to "false" .',
    )
    messageTemplate: str = Field(
        ..., description='The message template as a flux interpolated string.'
    )
    parseMode: Optional[ParseMode] = Field(
        None,
        description='Parse mode of the message text per https://core.telegram.org/bots/api#formatting-options . Defaults to "MarkdownV2" .',
    )
    type: Type35 = Field(
        ...,
        description='The discriminator between other types of notification rules is "telegram".',
    )


class Meta2(BaseModel):
    name: Optional[str] = None


class Action1(Enum):
    skipKind = 'skipKind'


class Action2(Enum):
    skipResource = 'skipResource'


class Remote(BaseModel):
    contentType: Optional[str] = None
    url: str


class TemplateEnvReference(BaseModel):
    defaultValue: Optional[Union[str, int, float, bool]] = Field(
        None,
        description='Default value that will be provided for the reference when no value is provided',
    )
    envRefKey: str = Field(
        ...,
        description='Key identified as environment reference and is the key identified in the template',
    )
    resourceField: str = Field(
        ..., description='Field the environment reference corresponds too'
    )
    value: Optional[Union[str, int, float, bool]] = Field(
        None, description='Value provided to fulfill reference'
    )


class TemplateEnvReferences(RootModel[List[TemplateEnvReference]]):
    root: List[TemplateEnvReference]


class TemplateKind(Enum):
    Bucket = 'Bucket'
    Check = 'Check'
    CheckDeadman = 'CheckDeadman'
    CheckThreshold = 'CheckThreshold'
    Dashboard = 'Dashboard'
    Label = 'Label'
    NotificationEndpoint = 'NotificationEndpoint'
    NotificationEndpointHTTP = 'NotificationEndpointHTTP'
    NotificationEndpointPagerDuty = 'NotificationEndpointPagerDuty'
    NotificationEndpointSlack = 'NotificationEndpointSlack'
    NotificationRule = 'NotificationRule'
    Task = 'Task'
    Telegraf = 'Telegraf'
    Variable = 'Variable'


class New(BaseModel):
    description: Optional[str] = None
    name: Optional[str] = None
    retentionRules: Optional[RetentionRules] = None


class Old(BaseModel):
    description: Optional[str] = None
    name: Optional[str] = None
    retentionRules: Optional[RetentionRules] = None


class Bucket1(BaseModel):
    id: Optional[str] = None
    kind: Optional[TemplateKind] = None
    new: Optional[New] = None
    old: Optional[Old] = None
    stateStatus: Optional[str] = None
    templateMetaName: Optional[str] = None


class LabelMapping1(BaseModel):
    labelID: Optional[str] = None
    labelName: Optional[str] = None
    labelTemplateMetaName: Optional[str] = None
    resourceID: Optional[str] = None
    resourceName: Optional[str] = None
    resourceTemplateMetaName: Optional[str] = None
    resourceType: Optional[str] = None
    status: Optional[str] = None


class New2(BaseModel):
    color: Optional[str] = None
    description: Optional[str] = None
    name: Optional[str] = None


class Old2(BaseModel):
    color: Optional[str] = None
    description: Optional[str] = None
    name: Optional[str] = None


class Label1(BaseModel):
    id: Optional[str] = None
    kind: Optional[TemplateKind] = None
    new: Optional[New2] = None
    old: Optional[Old2] = None
    stateStatus: Optional[str] = None
    templateMetaName: Optional[str] = None


class StatusRule1(BaseModel):
    currentLevel: Optional[str] = None
    previousLevel: Optional[str] = None


class TagRule1(BaseModel):
    key: Optional[str] = None
    operator: Optional[str] = None
    value: Optional[str] = None


class New3(BaseModel):
    description: Optional[str] = None
    endpointID: Optional[str] = None
    endpointName: Optional[str] = None
    endpointType: Optional[str] = None
    every: Optional[str] = None
    messageTemplate: Optional[str] = None
    name: Optional[str] = None
    offset: Optional[str] = None
    status: Optional[str] = None
    statusRules: Optional[List[StatusRule1]] = None
    tagRules: Optional[List[TagRule1]] = None


class Old3(BaseModel):
    description: Optional[str] = None
    endpointID: Optional[str] = None
    endpointName: Optional[str] = None
    endpointType: Optional[str] = None
    every: Optional[str] = None
    messageTemplate: Optional[str] = None
    name: Optional[str] = None
    offset: Optional[str] = None
    status: Optional[str] = None
    statusRules: Optional[List[StatusRule1]] = None
    tagRules: Optional[List[TagRule1]] = None


class NotificationRule1(BaseModel):
    id: Optional[str] = None
    kind: Optional[TemplateKind] = None
    new: Optional[New3] = None
    old: Optional[Old3] = None
    stateStatus: Optional[str] = None
    templateMetaName: Optional[str] = None


class New4(BaseModel):
    cron: Optional[str] = None
    description: Optional[str] = None
    every: Optional[str] = None
    name: Optional[str] = None
    offset: Optional[str] = None
    query: Optional[str] = None
    status: Optional[str] = None


class Old4(BaseModel):
    cron: Optional[str] = None
    description: Optional[str] = None
    every: Optional[str] = None
    name: Optional[str] = None
    offset: Optional[str] = None
    query: Optional[str] = None
    status: Optional[str] = None


class Task1(BaseModel):
    id: Optional[str] = None
    kind: Optional[TemplateKind] = None
    new: Optional[New4] = None
    old: Optional[Old4] = None
    stateStatus: Optional[str] = None
    templateMetaName: Optional[str] = None


class TelegrafConfig(BaseModel):
    id: Optional[str] = None
    kind: Optional[TemplateKind] = None
    new: Optional[TelegrafRequest] = None
    old: Optional[TelegrafRequest] = None
    stateStatus: Optional[str] = None
    templateMetaName: Optional[str] = None


class Error2(BaseModel):
    fields: Optional[List[str]] = None
    indexes: Optional[List[int]] = None
    kind: Optional[TemplateKind] = None
    reason: Optional[str] = None


class Task2(BaseModel):
    cron: Optional[str] = None
    description: Optional[str] = None
    envReferences: Optional[TemplateEnvReferences] = None
    every: Optional[str] = None
    id: Optional[str] = None
    kind: Optional[TemplateKind] = None
    name: Optional[str] = None
    offset: Optional[str] = None
    query: Optional[str] = None
    status: Optional[str] = None
    templateMetaName: Optional[str] = None


class Properties2(BaseModel):
    color: Optional[str] = None
    description: Optional[str] = None


class TemplateSummaryLabel(BaseModel):
    envReferences: Optional[TemplateEnvReferences] = None
    id: Optional[str] = None
    kind: Optional[TemplateKind] = None
    name: Optional[str] = None
    orgID: Optional[str] = None
    properties: Optional[Properties2] = None
    templateMetaName: Optional[str] = None


class ThresholdBase(BaseModel):
    allValues: Optional[bool] = Field(
        None, description='If true, only alert if all values meet threshold.'
    )
    level: Optional[CheckStatusLevel] = None


class Type36(Enum):
    threshold = 'threshold'


class UnsignedIntegerLiteral(BaseModel):
    type: Optional[NodeType] = None
    value: Optional[str] = None


class Status9(Enum):
    active = 'active'
    inactive = 'inactive'


class User(BaseModel):
    id: Optional[str] = None
    name: str
    oauthID: Optional[str] = None
    status: Optional[Status9] = Field(
        'active', description='If inactive the user is inactive.'
    )


class Links21(BaseModel):
    self: Optional[AnyUrl] = None


class UserResponse(BaseModel):
    id: Optional[str] = None
    links: Optional[Links21] = Field(None, examples=[{'self': '/api/v2/users/1'}])
    name: str
    oauthID: Optional[str] = None
    status: Optional[Status9] = Field(
        'active', description='If inactive the user is inactive.'
    )


class Users(BaseModel):
    links: Optional[Links21] = None
    users: Optional[List[UserResponse]] = None


class Links23(BaseModel):
    labels: Optional[AnyUrl] = None
    org: Optional[AnyUrl] = None
    self: Optional[AnyUrl] = None


class VariableProperties(
    RootModel[
        Union[
            QueryVariableProperties, ConstantVariableProperties, MapVariableProperties
        ]
    ]
):
    root: Union[
        QueryVariableProperties, ConstantVariableProperties, MapVariableProperties
    ]


class Links24(BaseModel):
    self: Optional[str] = None


class WritePrecision(Enum):
    ms = 'ms'
    s = 's'
    us = 'us'
    ns = 'ns'


class XYGeom(Enum):
    line = 'line'
    step = 'step'
    stacked = 'stacked'
    bar = 'bar'
    monotoneX = 'monotoneX'


class Type37(Enum):
    xy = 'xy'


class SortBy(Enum):
    ID = 'ID'
    CreatedAt = 'CreatedAt'
    UpdatedAt = 'UpdatedAt'


class Id(RootModel[List[str]]):
    root: List[str]


class Include(Enum):
    properties = 'properties'


class AcceptEncoding(Enum):
    gzip = 'gzip'
    identity = 'identity'


class ContentType(Enum):
    application_json = 'application/json'
    application_vnd_flux = 'application/vnd.flux'


class ContentType1(Enum):
    application_json = 'application/json'


class StacksPostRequest(BaseModel):
    description: Optional[str] = None
    name: Optional[str] = None
    orgID: Optional[str] = None
    urls: Optional[List[str]] = None


class AdditionalResource(BaseModel):
    kind: str
    resourceID: str
    templateMetaName: Optional[str] = None


class StacksStackIdPatchRequest(BaseModel):
    additionalResources: Optional[List[AdditionalResource]] = None
    description: Optional[str] = None
    name: Optional[str] = None
    templateURLs: Optional[List[str]] = None


class TasksTaskIDRunsRunIDRetryPostRequest(BaseModel):
    pass


class Accept(Enum):
    application_toml = 'application/toml'
    application_json = 'application/json'
    application_octet_stream = 'application/octet-stream'


class ContentEncoding(Enum):
    gzip = 'gzip'
    identity = 'identity'


class ContentType3(Enum):
    text_plain = 'text/plain'
    text_plain__charset_utf_8 = 'text/plain; charset=utf-8'
    application_vnd_influx_arrow = 'application/vnd.influx.arrow'


class Accept1(Enum):
    application_json = 'application/json'


class LinksModel(BaseModel):
    self: Optional[Link] = None
    user: Optional[Link] = None


class Axis(BaseModel):
    base: Optional[Base] = Field(
        None, description='Base represents the radix for formatting axis values.'
    )
    bounds: Optional[List[str]] = Field(
        None,
        description='The extents of an axis in the form [lower, upper]. Clients determine whether bounds are to be inclusive or exclusive of their limits',
        max_length=2,
        min_length=0,
    )
    label: Optional[str] = Field(
        None, description='Label is a description of this Axis'
    )
    prefix: Optional[str] = Field(
        None, description='Prefix represents a label prefix for formatting axis values.'
    )
    scale: Optional[AxisScale] = None
    suffix: Optional[str] = Field(
        None, description='Suffix represents a label suffix for formatting axis values.'
    )


class BadStatement(BaseModel):
    text: Optional[str] = Field(None, description='Raw source text')
    type: Optional[NodeType] = None


class BooleanLiteral(BaseModel):
    type: Optional[NodeType] = None
    value: Optional[bool] = None


class Links1(BaseModel):
    labels: Optional[Link] = Field(
        None, description='URL to retrieve labels for this bucket'
    )
    members: Optional[Link] = Field(
        None, description='URL to retrieve members that can read this bucket'
    )
    org: Optional[Link] = Field(
        None, description='URL to retrieve parent organization for this bucket'
    )
    owners: Optional[Link] = Field(
        None,
        description='URL to retrieve owners that can read and write to this bucket.',
    )
    self: Optional[Link] = Field(None, description='URL for this bucket')
    write: Optional[Link] = Field(
        None, description='URL to write line protocol for this bucket'
    )


class Bucket(BaseModel):
    createdAt: Optional[datetime] = None
    description: Optional[str] = None
    id: Optional[str] = None
    labels: Optional[Labels] = None
    links: Optional[Links1] = Field(
        None,
        examples=[
            {
                'labels': '/api/v2/buckets/1/labels',
                'members': '/api/v2/buckets/1/members',
                'org': '/api/v2/orgs/2',
                'owners': '/api/v2/buckets/1/owners',
                'self': '/api/v2/buckets/1',
                'write': '/api/v2/write?org=2&amp;bucket=1',
            }
        ],
    )
    name: str
    orgID: Optional[str] = None
    retentionRules: RetentionRules
    rp: Optional[str] = None
    schemaType: Optional[SchemaType] = 'implicit'
    type: Optional[Type1] = 'user'
    updatedAt: Optional[datetime] = None


class Buckets(BaseModel):
    buckets: Optional[List[Bucket]] = None
    links: Optional[Links] = None


class BuilderConfig(BaseModel):
    aggregateWindow: Optional[AggregateWindow] = None
    buckets: Optional[List[str]] = None
    functions: Optional[List[BuilderFunctionsType]] = None
    tags: Optional[List[BuilderTagsType]] = None


class Links3(BaseModel):
    labels: Optional[Link] = Field(
        None, description='URL to retrieve labels for this check'
    )
    members: Optional[Link] = Field(
        None, description='URL to retrieve members for this check'
    )
    owners: Optional[Link] = Field(
        None, description='URL to retrieve owners for this check'
    )
    query: Optional[Link] = Field(
        None, description='URL to retrieve flux script for this check'
    )
    self: Optional[Link] = Field(None, description='URL for this check')


class DBRP1(BaseModel):
    bucketID: str = Field(
        ..., description='the bucket ID used as target for the translation.'
    )
    database: str = Field(..., description='InfluxDB v1 database')
    default: Optional[bool] = Field(
        None,
        description='Specify if this mapping represents the default retention policy for the database specificed.',
    )
    id: Optional[str] = Field(None, description='the mapping identifier')
    links: Optional[Links] = None
    org: Optional[str] = Field(
        None, description='the organization that owns this mapping.'
    )
    orgID: str = Field(..., description='the organization ID that owns this mapping.')
    retention_policy: str = Field(..., description='InfluxDB v1 retention policy')


class DBRP2(BaseModel):
    bucketID: str = Field(
        ..., description='the bucket ID used as target for the translation.'
    )
    database: str = Field(..., description='InfluxDB v1 database')
    default: Optional[bool] = Field(
        None,
        description='Specify if this mapping represents the default retention policy for the database specificed.',
    )
    id: Optional[str] = Field(None, description='the mapping identifier')
    links: Optional[Links] = None
    org: str = Field(..., description='the organization that owns this mapping.')
    orgID: Optional[str] = Field(
        None, description='the organization ID that owns this mapping.'
    )
    retention_policy: str = Field(..., description='InfluxDB v1 retention policy')


class DBRP(RootModel[Union[DBRP1, DBRP2]]):
    root: Union[DBRP1, DBRP2]


class DBRPUpdate(BaseModel):
    database: Optional[str] = Field(None, description='InfluxDB v1 database')
    default: Optional[bool] = None
    links: Optional[Links] = None
    retention_policy: Optional[str] = Field(
        None, description='InfluxDB v1 retention policy'
    )


class DBRPs(BaseModel):
    content: Optional[List[DBRP]] = None


class Links4(BaseModel):
    cells: Optional[Link] = None
    labels: Optional[Link] = None
    members: Optional[Link] = None
    org: Optional[Link] = None
    owners: Optional[Link] = None
    self: Optional[Link] = None


class Dashboard(CreateDashboardRequest):
    cells: Optional[Cells] = None
    id: Optional[str] = None
    labels: Optional[Labels] = None
    links: Optional[Links4] = Field(
        None,
        examples=[
            {
                'cells': '/api/v2/dashboards/1/cells',
                'labels': '/api/v2/dashboards/1/labels',
                'members': '/api/v2/dashboards/1/members',
                'org': '/api/v2/labels/1',
                'owners': '/api/v2/dashboards/1/owners',
                'self': '/api/v2/dashboards/1',
            }
        ],
    )
    meta: Optional[Meta] = None


class DashboardQuery(BaseModel):
    builderConfig: Optional[BuilderConfig] = None
    editMode: Optional[QueryEditMode] = None
    name: Optional[str] = None
    text: Optional[str] = Field(None, description='The text of the Flux query.')


class Dashboards(BaseModel):
    dashboards: Optional[List[Dashboard]] = None
    links: Optional[Links] = None


class DateTimeLiteral(BaseModel):
    type: Optional[NodeType] = None
    value: Optional[datetime] = None


class Links6(BaseModel):
    self: Optional[Link] = Field(None, description='The document URL.')


class Document(BaseModel):
    content: Dict[str, Any]
    id: str
    labels: Optional[Labels] = None
    links: Optional[Links6] = Field(
        None, examples=[{'self': '/api/v2/documents/templates/1'}]
    )
    meta: DocumentMeta


class DocumentCreate(BaseModel):
    content: Dict[str, Any]
    labels: Optional[List[str]] = Field(
        None, description='An array of label IDs to be added as labels to the document.'
    )
    meta: DocumentMeta
    org: Optional[str] = Field(
        None, description='The organization Name. Specify either `orgID` or `org`.'
    )
    orgID: Optional[str] = Field(
        None, description='The organization Name. Specify either `orgID` or `org`.'
    )


class DocumentListEntry(BaseModel):
    id: str
    labels: Optional[Labels] = None
    links: Optional[Links6] = Field(
        None, examples=[{'self': '/api/v2/documents/templates/1'}]
    )
    meta: DocumentMeta


class Documents(BaseModel):
    documents: Optional[List[DocumentListEntry]] = None


class Duration(BaseModel):
    magnitude: Optional[int] = None
    type: Optional[NodeType] = None
    unit: Optional[str] = None


class DurationLiteral(BaseModel):
    type: Optional[NodeType] = None
    values: Optional[List[Duration]] = Field(None, description='Duration values')


class FloatLiteral(BaseModel):
    type: Optional[NodeType] = None
    value: Optional[float] = None


class GaugeViewProperties(BaseModel):
    colors: List[DashboardColor] = Field(
        ..., description='Colors define color encoding of data into a visualization'
    )
    decimalPlaces: DecimalPlaces
    note: str
    prefix: str
    queries: List[DashboardQuery]
    shape: Shape
    showNoteWhenEmpty: bool = Field(
        ..., description='If true, will display note when empty'
    )
    suffix: str
    tickPrefix: str
    tickSuffix: str
    type: Type8


class GeoCircleViewLayer(GeoViewLayerProperties):
    colorDimension: Axis
    colorField: str = Field(..., description='Circle color field')
    colors: List[DashboardColor] = Field(
        ..., description='Colors define color encoding of data into a visualization'
    )
    interpolateColors: Optional[bool] = Field(
        None, description='Interpolate circle color based on displayed value'
    )
    radius: Optional[int] = Field(None, description='Maximum radius size in pixels')
    radiusDimension: Axis
    radiusField: str = Field(..., description='Radius field')


class GeoHeatMapViewLayer(GeoViewLayerProperties):
    blur: int = Field(..., description='Blur for heatmap points')
    colors: List[DashboardColor] = Field(
        ..., description='Colors define color encoding of data into a visualization'
    )
    intensityDimension: Axis
    intensityField: str = Field(..., description='Intensity field')
    radius: int = Field(..., description='Radius size in pixels')


class GeoPointMapViewLayer(GeoViewLayerProperties):
    colorDimension: Axis
    colorField: str = Field(..., description='Marker color field')
    colors: List[DashboardColor] = Field(
        ..., description='Colors define color encoding of data into a visualization'
    )
    isClustered: Optional[bool] = Field(
        None, description='Cluster close markers together'
    )


class GeoTrackMapViewLayer(GeoViewLayerProperties):
    colors: Optional[List[DashboardColor]] = Field(
        None, description='Colors define color encoding of data into a visualization'
    )
    randomColors: bool = Field(
        ..., description='Assign different colors to different tracks'
    )
    speed: int = Field(..., description='Speed of the track animation')
    trackWidth: int = Field(..., description='Width of the track')


class GeoViewLayer(
    RootModel[
        Union[
            GeoCircleViewLayer,
            GeoHeatMapViewLayer,
            GeoPointMapViewLayer,
            GeoTrackMapViewLayer,
        ]
    ]
):
    root: Union[
        GeoCircleViewLayer,
        GeoHeatMapViewLayer,
        GeoPointMapViewLayer,
        GeoTrackMapViewLayer,
    ]


class GeoViewProperties(BaseModel):
    allowPanAndZoom: bool = Field(
        ...,
        description='If true, map zoom and pan controls are enabled on the dashboard view',
    )
    center: Center = Field(..., description='Coordinates of the center of the map')
    colors: Optional[List[DashboardColor]] = Field(
        None, description='Colors define color encoding of data into a visualization'
    )
    detectCoordinateFields: bool = Field(
        ...,
        description='If true, search results get automatically regroupped so that lon,lat and value are treated as columns',
    )
    layers: List[GeoViewLayer] = Field(
        ..., description='List of individual layers shown in the map'
    )
    mapStyle: Optional[str] = Field(
        None, description='Define map type - regular, satellite etc.'
    )
    note: str
    queries: List[DashboardQuery]
    shape: Shape
    showNoteWhenEmpty: bool = Field(
        ..., description='If true, will display note when empty'
    )
    type: Type10
    zoom: confloat(ge=1.0, le=28.0) = Field(
        ..., description='Zoom level used for initial display of the map'
    )


class GreaterThreshold(ThresholdBase):
    type: Literal['greater']
    value: float


class HeatmapViewProperties(BaseModel):
    binSize: float
    colors: List[str] = Field(
        ..., description='Colors define color encoding of data into a visualization'
    )
    generateXAxisTicks: Optional[List[str]] = None
    generateYAxisTicks: Optional[List[str]] = None
    legendColorizeRows: Optional[bool] = None
    legendHide: Optional[bool] = None
    legendOpacity: Optional[float] = None
    legendOrientationThreshold: Optional[int] = None
    note: str
    queries: List[DashboardQuery]
    shape: Shape
    showNoteWhenEmpty: bool = Field(
        ..., description='If true, will display note when empty'
    )
    timeFormat: Optional[str] = None
    type: Type13
    xAxisLabel: str
    xColumn: str
    xDomain: List[float] = Field(..., max_length=2)
    xPrefix: str
    xSuffix: str
    xTickStart: Optional[float] = None
    xTickStep: Optional[float] = None
    xTotalTicks: Optional[int] = None
    yAxisLabel: str
    yColumn: str
    yDomain: List[float] = Field(..., max_length=2)
    yPrefix: str
    ySuffix: str
    yTickStart: Optional[float] = None
    yTickStep: Optional[float] = None
    yTotalTicks: Optional[int] = None


class HistogramViewProperties(BaseModel):
    binCount: int
    colors: List[DashboardColor] = Field(
        ..., description='Colors define color encoding of data into a visualization'
    )
    fillColumns: List[str]
    legendColorizeRows: Optional[bool] = None
    legendHide: Optional[bool] = None
    legendOpacity: Optional[float] = None
    legendOrientationThreshold: Optional[int] = None
    note: str
    position: Position
    queries: List[DashboardQuery]
    shape: Shape
    showNoteWhenEmpty: bool = Field(
        ..., description='If true, will display note when empty'
    )
    type: Type14
    xAxisLabel: str
    xColumn: str
    xDomain: List[float]


class Identifier(BaseModel):
    name: Optional[str] = None
    type: Optional[NodeType] = None


class ImportDeclaration(BaseModel):
    as_: Optional[Identifier] = Field(None, alias='as')
    path: Optional[StringLiteral] = None
    type: Optional[NodeType] = None


class IntegerLiteral(BaseModel):
    type: Optional[NodeType] = None
    value: Optional[str] = None


class LabelResponse(BaseModel):
    label: Optional[Label] = None
    links: Optional[Links] = None


class LabelsResponse(BaseModel):
    labels: Optional[Labels] = None
    links: Optional[Links] = None


class LesserThreshold(ThresholdBase):
    type: Literal['lesser']
    value: float


class MosaicViewProperties(BaseModel):
    colors: List[str] = Field(
        ..., description='Colors define color encoding of data into a visualization'
    )
    fillColumns: List[str]
    generateXAxisTicks: Optional[List[str]] = None
    hoverDimension: Optional[HoverDimension] = None
    legendColorizeRows: Optional[bool] = None
    legendHide: Optional[bool] = None
    legendOpacity: Optional[float] = None
    legendOrientationThreshold: Optional[int] = None
    note: str
    queries: List[DashboardQuery]
    shape: Shape
    showNoteWhenEmpty: bool = Field(
        ..., description='If true, will display note when empty'
    )
    timeFormat: Optional[str] = None
    type: Type20
    xAxisLabel: str
    xColumn: str
    xDomain: List[float] = Field(..., max_length=2)
    xPrefix: str
    xSuffix: str
    xTickStart: Optional[float] = None
    xTickStep: Optional[float] = None
    xTotalTicks: Optional[int] = None
    yAxisLabel: str
    yDomain: List[float] = Field(..., max_length=2)
    yLabelColumnSeparator: Optional[str] = None
    yLabelColumns: Optional[List[str]] = None
    yPrefix: str
    ySeriesColumns: List[str]
    ySuffix: str


class NotificationEndpointBase(BaseModel):
    createdAt: Optional[datetime] = None
    description: Optional[str] = Field(
        None, description='An optional description of the notification endpoint.'
    )
    id: Optional[str] = None
    labels: Optional[Labels] = None
    links: Optional[Links8] = Field(
        None,
        examples=[
            {
                'labels': '/api/v2/notificationEndpoints/1/labels',
                'members': '/api/v2/notificationEndpoints/1/members',
                'owners': '/api/v2/notificationEndpoints/1/owners',
                'self': '/api/v2/notificationEndpoints/1',
            }
        ],
    )
    name: str
    orgID: Optional[str] = None
    status: Optional[Status3] = Field(
        'active', description='The status of the endpoint.'
    )
    type: NotificationEndpointType
    updatedAt: Optional[datetime] = None
    userID: Optional[str] = None


class NotificationRuleBase(BaseModel):
    createdAt: Optional[datetime] = None
    description: Optional[str] = Field(
        None, description='An optional description of the notification rule.'
    )
    endpointID: str
    every: Optional[str] = Field(
        None, description='The notification repetition interval.'
    )
    id: Optional[str] = None
    labels: Optional[Labels] = None
    lastRunError: Optional[str] = None
    lastRunStatus: Optional[LastRunStatus] = None
    latestCompleted: Optional[datetime] = Field(
        None, description='Timestamp of latest scheduled, completed run, RFC3339.'
    )
    limit: Optional[int] = Field(
        None,
        description="Don't notify me more than &lt;limit&gt; times every &lt;limitEvery&gt; seconds. If set, limitEvery cannot be empty.",
    )
    limitEvery: Optional[int] = Field(
        None,
        description="Don't notify me more than &lt;limit&gt; times every &lt;limitEvery&gt; seconds. If set, limit cannot be empty.",
    )
    links: Optional[Links9] = Field(
        None,
        examples=[
            {
                'labels': '/api/v2/notificationRules/1/labels',
                'members': '/api/v2/notificationRules/1/members',
                'owners': '/api/v2/notificationRules/1/owners',
                'query': '/api/v2/notificationRules/1/query',
                'self': '/api/v2/notificationRules/1',
            }
        ],
    )
    name: str = Field(
        ..., description='Human-readable name describing the notification rule.'
    )
    offset: Optional[str] = Field(
        None,
        description='Duration to delay after the schedule, before executing check.',
    )
    orgID: str = Field(
        ..., description='The ID of the organization that owns this notification rule.'
    )
    ownerID: Optional[str] = Field(
        None, description='The ID of creator used to create this notification rule.'
    )
    runbookLink: Optional[str] = None
    sleepUntil: Optional[str] = None
    status: TaskStatusType
    statusRules: List[StatusRule] = Field(
        ...,
        description='List of status rules the notification rule attempts to match.',
        min_length=1,
    )
    tagRules: Optional[List[TagRule]] = Field(
        None, description='List of tag rules the notification rule attempts to match.'
    )
    taskID: Optional[str] = Field(
        None, description='The ID of the task associated with this notification rule.'
    )
    updatedAt: Optional[datetime] = None


class PackageClause(BaseModel):
    name: Optional[Identifier] = None
    type: Optional[NodeType] = None


class PagerDutyNotificationEndpoint(NotificationEndpointBase):
    clientURL: Optional[str] = None
    routingKey: str
    type: Literal['pagerduty']


class PagerDutyNotificationRule(NotificationRuleBase, PagerDutyNotificationRuleBase):
    type: Literal['pagerduty']


class PatchBucketRequest(BaseModel):
    description: Optional[str] = None
    name: Optional[str] = None
    retentionRules: Optional[PatchRetentionRules] = None


class Permission(BaseModel):
    action: Action
    resource: Resource


class PostBucketRequest(BaseModel):
    description: Optional[str] = None
    name: str
    orgID: str
    retentionRules: RetentionRules
    rp: Optional[str] = None
    schemaType: Optional[SchemaType] = 'implicit'


class PropertyKey(RootModel[Union[Identifier, StringLiteral]]):
    root: Union[Identifier, StringLiteral]


class RangeThreshold(ThresholdBase):
    max: float
    min: float
    type: Literal['range']
    within: bool


class ResourceMember(UserResponse):
    role: Optional[Role] = 'member'


class ResourceMembers(BaseModel):
    links: Optional[Links11] = None
    users: Optional[List[ResourceMember]] = None


class ResourceOwner(UserResponse):
    role: Optional[Role1] = 'owner'


class ResourceOwners(BaseModel):
    links: Optional[Links11] = None
    users: Optional[List[ResourceOwner]] = None


class SMTPNotificationRule(NotificationRuleBase, SMTPNotificationRuleBase):
    type: Literal['smtp']


class ScatterViewProperties(BaseModel):
    colors: List[str] = Field(
        ..., description='Colors define color encoding of data into a visualization'
    )
    fillColumns: List[str]
    generateXAxisTicks: Optional[List[str]] = None
    generateYAxisTicks: Optional[List[str]] = None
    legendColorizeRows: Optional[bool] = None
    legendHide: Optional[bool] = None
    legendOpacity: Optional[float] = None
    legendOrientationThreshold: Optional[int] = None
    note: str
    queries: List[DashboardQuery]
    shape: Shape
    showNoteWhenEmpty: bool = Field(
        ..., description='If true, will display note when empty'
    )
    symbolColumns: List[str]
    timeFormat: Optional[str] = None
    type: Type29
    xAxisLabel: str
    xColumn: str
    xDomain: List[float] = Field(..., max_length=2)
    xPrefix: str
    xSuffix: str
    xTickStart: Optional[float] = None
    xTickStep: Optional[float] = None
    xTotalTicks: Optional[int] = None
    yAxisLabel: str
    yColumn: str
    yDomain: List[float] = Field(..., max_length=2)
    yPrefix: str
    ySuffix: str
    yTickStart: Optional[float] = None
    yTickStep: Optional[float] = None
    yTotalTicks: Optional[int] = None


class SingleStatViewProperties(BaseModel):
    colors: List[DashboardColor] = Field(
        ..., description='Colors define color encoding of data into a visualization'
    )
    decimalPlaces: DecimalPlaces
    note: str
    prefix: str
    queries: List[DashboardQuery]
    shape: Shape
    showNoteWhenEmpty: bool = Field(
        ..., description='If true, will display note when empty'
    )
    staticLegend: Optional[StaticLegend] = None
    suffix: str
    tickPrefix: str
    tickSuffix: str
    type: Type31


class SlackNotificationEndpoint(NotificationEndpointBase):
    token: Optional[str] = Field(
        None,
        description='Specifies the API token string. Specify either `URL` or `Token`.',
    )
    url: Optional[str] = Field(
        None,
        description='Specifies the URL of the Slack endpoint. Specify either `URL` or `Token`.',
    )
    type: Literal['slack']


class SlackNotificationRule(NotificationRuleBase, SlackNotificationRuleBase):
    type: Literal['slack']


class Association(BaseModel):
    kind: Optional[TemplateKind] = None
    metaName: Optional[str] = None


class Resource1(BaseModel):
    apiVersion: Optional[str] = None
    associations: Optional[List[Association]] = None
    kind: Optional[TemplateKind] = None
    links: Optional[Links18] = None
    resourceID: Optional[str] = None
    templateMetaName: Optional[str] = None


class Event(BaseModel):
    description: Optional[str] = None
    eventType: Optional[str] = None
    name: Optional[str] = None
    resources: Optional[List[Resource1]] = None
    sources: Optional[List[str]] = None
    updatedAt: Optional[datetime] = None
    urls: Optional[List[str]] = None


class Stack(BaseModel):
    createdAt: Optional[datetime] = None
    events: Optional[List[Event]] = None
    id: Optional[str] = None
    orgID: Optional[str] = None


class TableViewProperties(BaseModel):
    colors: List[DashboardColor] = Field(
        ..., description='Colors define color encoding of data into a visualization'
    )
    decimalPlaces: DecimalPlaces
    fieldOptions: List[RenamableField] = Field(
        ...,
        description='fieldOptions represent the fields retrieved by the query with customization options',
    )
    note: str
    queries: List[DashboardQuery]
    shape: Shape
    showNoteWhenEmpty: bool = Field(
        ..., description='If true, will display note when empty'
    )
    tableOptions: TableOptions
    timeFormat: str = Field(
        ...,
        description='timeFormat describes the display format for time values according to moment.js date formatting',
    )
    type: Type34


class Task(BaseModel):
    authorizationID: Optional[str] = Field(
        None,
        description='The ID of the authorization used when this task communicates with the query engine.',
    )
    createdAt: Optional[datetime] = None
    cron: Optional[str] = Field(
        None,
        description="A task repetition schedule in the form '* * * * * *'; parsed from Flux.",
    )
    description: Optional[str] = Field(
        None, description='An optional description of the task.'
    )
    every: Optional[str] = Field(
        None, description='A simple task repetition schedule; parsed from Flux.'
    )
    flux: str = Field(..., description='The Flux script to run for this task.')
    id: str
    labels: Optional[Labels] = None
    lastRunError: Optional[str] = None
    lastRunStatus: Optional[LastRunStatus] = None
    latestCompleted: Optional[datetime] = Field(
        None, description='Timestamp of latest scheduled, completed run, RFC3339.'
    )
    links: Optional[Links19] = Field(
        None,
        examples=[
            {
                'labels': '/api/v2/tasks/1/labels',
                'logs': '/api/v2/tasks/1/logs',
                'members': '/api/v2/tasks/1/members',
                'owners': '/api/v2/tasks/1/owners',
                'runs': '/api/v2/tasks/1/runs',
                'self': '/api/v2/tasks/1',
            }
        ],
    )
    name: str = Field(..., description='The name of the task.')
    offset: Optional[str] = Field(
        None,
        description='Duration to delay after the schedule, before executing the task; parsed from flux, if set to zero it will remove this option and use 0 as the default.',
    )
    org: Optional[str] = Field(
        None, description='The name of the organization that owns this Task.'
    )
    orgID: str = Field(
        ..., description='The ID of the organization that owns this Task.'
    )
    status: Optional[TaskStatusType] = None
    type: Optional[str] = Field(
        None,
        description='The type of task, this can be used for filtering tasks on list actions.',
    )
    updatedAt: Optional[datetime] = None


class TaskCreateRequest(BaseModel):
    description: Optional[str] = Field(
        None, description='An optional description of the task.'
    )
    flux: str = Field(..., description='The Flux script to run for this task.')
    org: Optional[str] = Field(
        None, description='The name of the organization that owns this Task.'
    )
    orgID: Optional[str] = Field(
        None, description='The ID of the organization that owns this Task.'
    )
    status: Optional[TaskStatusType] = None


class Tasks(BaseModel):
    links: Optional[Links] = None
    tasks: Optional[List[Task]] = None


class Telegraf(TelegrafRequest):
    id: Optional[str] = None
    labels: Optional[Labels] = None
    links: Optional[Links20] = Field(
        None,
        examples=[
            {
                'lables': '/api/v2/telegrafs/1/labels',
                'members': '/api/v2/telegrafs/1/members',
                'owners': '/api/v2/telegrafs/1/owners',
                'self': '/api/v2/telegrafs/1',
            }
        ],
    )


class Telegrafs(BaseModel):
    configurations: Optional[List[Telegraf]] = None


class TelegramNotificationEndpoint(NotificationEndpointBase):
    channel: str = Field(
        ...,
        description='ID of the telegram channel, a chat_id in https://core.telegram.org/bots/api#sendmessage .',
    )
    token: str = Field(
        ...,
        description='Specifies the Telegram bot token. See https://core.telegram.org/bots#creating-a-new-bot .',
    )
    type: Literal['telegram']


class TelegramNotificationRule(NotificationRuleBase, TelegramNotificationRuleBase):
    type: Literal['telegram']


class TemplateItem(BaseModel):
    apiVersion: Optional[str] = None
    kind: Optional[TemplateKind] = None
    meta: Optional[Meta2] = None
    spec: Optional[Dict[str, Any]] = None


class Template(RootModel[List[TemplateItem]]):
    root: List[TemplateItem]


class Properties(BaseModel):
    kind: TemplateKind


class Actions(BaseModel):
    action: Optional[Action1] = None
    properties: Optional[Properties] = None


class Properties1(BaseModel):
    kind: TemplateKind
    resourceTemplateName: str


class Actions1(BaseModel):
    action: Optional[Action2] = None
    properties: Optional[Properties1] = None


class Template1(BaseModel):
    contentType: Optional[str] = None
    contents: Optional[Template] = None
    sources: Optional[List[str]] = None


class TemplateApply(BaseModel):
    actions: Optional[List[Union[Actions, Actions1]]] = None
    dryRun: Optional[bool] = None
    envRefs: Optional[Dict[str, Union[str, int, float, bool]]] = None
    orgID: Optional[str] = None
    remotes: Optional[List[Remote]] = None
    secrets: Optional[Dict[str, str]] = None
    stackID: Optional[str] = None
    template: Optional[Template1] = None
    templates: Optional[List[Template1]] = None


class ResourceFilters(BaseModel):
    byLabel: Optional[List[str]] = None
    byResourceKind: Optional[List[TemplateKind]] = None


class OrgID(BaseModel):
    orgID: Optional[str] = None
    resourceFilters: Optional[ResourceFilters] = None


class Resources(BaseModel):
    id: str
    kind: TemplateKind
    name: Optional[str] = Field(
        None,
        description='if defined with id, name is used for resource exported by id. if defined independently, resources strictly matching name are exported',
    )


class TemplateExportByID(BaseModel):
    orgIDs: Optional[List[OrgID]] = None
    resources: Optional[Resources] = None
    stackID: Optional[str] = None


class OrgID1(BaseModel):
    orgID: Optional[str] = None
    resourceFilters: Optional[ResourceFilters] = None


class Resources1(BaseModel):
    kind: TemplateKind
    name: str


class TemplateExportByName(BaseModel):
    orgIDs: Optional[List[OrgID1]] = None
    resources: Optional[Resources1] = None
    stackID: Optional[str] = None


class New5(BaseModel):
    args: Optional[VariableProperties] = None
    description: Optional[str] = None
    name: Optional[str] = None


class Old5(BaseModel):
    args: Optional[VariableProperties] = None
    description: Optional[str] = None
    name: Optional[str] = None


class Variable(BaseModel):
    id: Optional[str] = None
    kind: Optional[TemplateKind] = None
    new: Optional[New5] = None
    old: Optional[Old5] = None
    stateStatus: Optional[str] = None
    templateMetaName: Optional[str] = None


class Bucket2(BaseModel):
    description: Optional[str] = None
    envReferences: Optional[TemplateEnvReferences] = None
    id: Optional[str] = None
    kind: Optional[TemplateKind] = None
    labelAssociations: Optional[List[TemplateSummaryLabel]] = None
    name: Optional[str] = None
    orgID: Optional[str] = None
    retentionPeriod: Optional[int] = None
    templateMetaName: Optional[str] = None


class NotificationRule2(BaseModel):
    description: Optional[str] = None
    endpointID: Optional[str] = None
    endpointTemplateMetaName: Optional[str] = None
    endpointType: Optional[str] = None
    envReferences: Optional[TemplateEnvReferences] = None
    every: Optional[str] = None
    kind: Optional[TemplateKind] = None
    labelAssociations: Optional[List[TemplateSummaryLabel]] = None
    messageTemplate: Optional[str] = None
    name: Optional[str] = None
    offset: Optional[str] = None
    status: Optional[str] = None
    statusRules: Optional[List[StatusRule1]] = None
    tagRules: Optional[List[TagRule1]] = None
    templateMetaName: Optional[str] = None


class TelegrafConfig1(TelegrafRequest):
    envReferences: Optional[TemplateEnvReferences] = None
    kind: Optional[TemplateKind] = None
    labelAssociations: Optional[List[TemplateSummaryLabel]] = None
    templateMetaName: Optional[str] = None


class Variable1(BaseModel):
    arguments: Optional[VariableProperties] = None
    description: Optional[str] = None
    envReferences: Optional[TemplateEnvReferences] = None
    id: Optional[str] = None
    kind: Optional[TemplateKind] = None
    labelAssociations: Optional[List[TemplateSummaryLabel]] = None
    name: Optional[str] = None
    orgID: Optional[str] = None
    templateMetaName: Optional[str] = None


class Threshold(RootModel[Union[GreaterThreshold, LesserThreshold, RangeThreshold]]):
    root: Union[GreaterThreshold, LesserThreshold, RangeThreshold] = Field(
        ..., discriminator='type'
    )


class Variable2(BaseModel):
    arguments: VariableProperties
    createdAt: Optional[datetime] = None
    description: Optional[str] = None
    id: Optional[str] = None
    labels: Optional[Labels] = None
    links: Optional[Links23] = None
    name: str
    orgID: str
    selected: Optional[List[str]] = None
    updatedAt: Optional[datetime] = None


class Variables(BaseModel):
    variables: Optional[List[Variable2]] = None


class StacksGetResponse(BaseModel):
    stacks: Optional[List[Stack]] = None


class TemplatesExportPostRequest(
    RootModel[Union[TemplateExportByID, TemplateExportByName]]
):
    root: Union[TemplateExportByID, TemplateExportByName]


class Authorization(AuthorizationUpdateRequest):
    createdAt: Optional[datetime] = None
    id: Optional[str] = None
    links: Optional[LinksModel] = Field(
        None,
        examples=[{'self': '/api/v2/authorizations/1', 'user': '/api/v2/users/12'}],
    )
    org: Optional[str] = Field(None, description='Name of the org token is scoped to.')
    orgID: str = Field(..., description='ID of org that authorization is scoped to.')
    permissions: List[Permission] = Field(
        ...,
        description='List of permissions for an auth.  An auth must have at least one Permission.',
        min_length=1,
    )
    token: Optional[str] = Field(
        None,
        description='Passed via the Authorization Header and Token Authentication type.',
    )
    updatedAt: Optional[datetime] = None
    user: Optional[str] = Field(
        None, description='Name of user that created and owns the token.'
    )
    userID: Optional[str] = Field(
        None, description='ID of user that created and owns the token.'
    )


class AuthorizationPostRequest(AuthorizationUpdateRequest):
    orgID: str = Field(..., description='ID of org that authorization is scoped to.')
    permissions: List[Permission] = Field(
        ...,
        description='List of permissions for an auth.  An auth must have at least one Permission.',
        min_length=1,
    )
    userID: Optional[str] = Field(
        None, description='ID of user that authorization is scoped to.'
    )


class Authorizations(BaseModel):
    authorizations: Optional[List[Authorization]] = None
    links: Optional[Links] = None


class Axes(BaseModel):
    x: Axis
    y: Axis


class BandViewProperties(BaseModel):
    axes: Axes
    colors: List[DashboardColor] = Field(
        ..., description='Colors define color encoding of data into a visualization'
    )
    generateXAxisTicks: Optional[List[str]] = None
    generateYAxisTicks: Optional[List[str]] = None
    geom: XYGeom
    hoverDimension: Optional[HoverDimension] = None
    legendColorizeRows: Optional[bool] = None
    legendHide: Optional[bool] = None
    legendOpacity: Optional[float] = None
    legendOrientationThreshold: Optional[int] = None
    lowerColumn: Optional[str] = None
    mainColumn: Optional[str] = None
    note: str
    queries: List[DashboardQuery]
    shape: Shape
    showNoteWhenEmpty: bool = Field(
        ..., description='If true, will display note when empty'
    )
    staticLegend: Optional[StaticLegend] = None
    timeFormat: Optional[str] = None
    type: Type
    upperColumn: Optional[str] = None
    xColumn: Optional[str] = None
    xTickStart: Optional[float] = None
    xTickStep: Optional[float] = None
    xTotalTicks: Optional[int] = None
    yColumn: Optional[str] = None
    yTickStart: Optional[float] = None
    yTickStep: Optional[float] = None
    yTotalTicks: Optional[int] = None


class BuiltinStatement(BaseModel):
    id: Optional[Identifier] = None
    type: Optional[NodeType] = None


class CheckBase(BaseModel):
    createdAt: Optional[datetime] = None
    description: Optional[str] = Field(
        None, description='An optional description of the check.'
    )
    id: Optional[str] = None
    labels: Optional[Labels] = None
    lastRunError: Optional[str] = None
    lastRunStatus: Optional[LastRunStatus] = None
    latestCompleted: Optional[datetime] = Field(
        None, description='Timestamp of latest scheduled, completed run, RFC3339.'
    )
    links: Optional[Links3] = Field(
        None,
        examples=[
            {
                'labels': '/api/v2/checks/1/labels',
                'members': '/api/v2/checks/1/members',
                'owners': '/api/v2/checks/1/owners',
                'query': '/api/v2/checks/1/query',
                'self': '/api/v2/checks/1',
            }
        ],
    )
    name: str
    orgID: str = Field(
        ..., description='The ID of the organization that owns this check.'
    )
    ownerID: Optional[str] = Field(
        None, description='The ID of creator used to create this check.'
    )
    query: DashboardQuery
    status: Optional[TaskStatusType] = None
    taskID: Optional[str] = Field(
        None, description='The ID of the task associated with this check.'
    )
    updatedAt: Optional[datetime] = None


class CustomCheck(CheckBase):
    type: Literal['custom']


class DeadmanCheck(CheckBase):
    every: Optional[str] = Field(None, description='Check repetition interval.')
    level: Optional[CheckStatusLevel] = None
    offset: Optional[str] = Field(
        None,
        description='Duration to delay after the schedule, before executing check.',
    )
    reportZero: Optional[bool] = Field(
        None, description='If only zero values reported since time, trigger an alert'
    )
    staleTime: Optional[str] = Field(
        None,
        description='String duration for time that a series is considered stale and should not trigger deadman.',
    )
    statusMessageTemplate: Optional[str] = Field(
        None, description='The template used to generate and write a status message.'
    )
    tags: Optional[List[Tag]] = Field(
        None, description='List of tags to write to each status.'
    )
    timeSince: Optional[str] = Field(
        None, description='String duration before deadman triggers.'
    )
    type: Literal['deadman']


class HTTPNotificationEndpoint(NotificationEndpointBase):
    authMethod: AuthMethod
    contentTemplate: Optional[str] = None
    headers: Optional[Dict[str, str]] = Field(None, description='Customized headers.')
    method: Method
    password: Optional[str] = None
    token: Optional[str] = None
    url: str
    username: Optional[str] = None
    type: Literal['http']


class HTTPNotificationRule(NotificationRuleBase, HTTPNotificationRuleBase):
    type: Literal['http']


class LinePlusSingleStatProperties(BaseModel):
    axes: Axes
    colors: List[DashboardColor] = Field(
        ..., description='Colors define color encoding of data into a visualization'
    )
    decimalPlaces: DecimalPlaces
    generateXAxisTicks: Optional[List[str]] = None
    generateYAxisTicks: Optional[List[str]] = None
    hoverDimension: Optional[HoverDimension] = None
    legendColorizeRows: Optional[bool] = None
    legendHide: Optional[bool] = None
    legendOpacity: Optional[float] = None
    legendOrientationThreshold: Optional[int] = None
    note: str
    position: Position
    prefix: str
    queries: List[DashboardQuery]
    shadeBelow: Optional[bool] = None
    shape: Shape
    showNoteWhenEmpty: bool = Field(
        ..., description='If true, will display note when empty'
    )
    staticLegend: Optional[StaticLegend] = None
    suffix: str
    timeFormat: Optional[str] = None
    type: Type17
    xColumn: Optional[str] = None
    xTickStart: Optional[float] = None
    xTickStep: Optional[float] = None
    xTotalTicks: Optional[int] = None
    yColumn: Optional[str] = None
    yTickStart: Optional[float] = None
    yTickStep: Optional[float] = None
    yTotalTicks: Optional[int] = None


class NotificationEndpointDiscriminator(
    RootModel[
        Union[
            SlackNotificationEndpoint,
            PagerDutyNotificationEndpoint,
            HTTPNotificationEndpoint,
            TelegramNotificationEndpoint,
        ]
    ]
):
    root: Union[
        SlackNotificationEndpoint,
        PagerDutyNotificationEndpoint,
        HTTPNotificationEndpoint,
        TelegramNotificationEndpoint,
    ] = Field(..., discriminator='type')


class NotificationRuleDiscriminator(
    RootModel[
        Union[
            SlackNotificationRule,
            SMTPNotificationRule,
            PagerDutyNotificationRule,
            HTTPNotificationRule,
            TelegramNotificationRule,
        ]
    ]
):
    root: Union[
        SlackNotificationRule,
        SMTPNotificationRule,
        PagerDutyNotificationRule,
        HTTPNotificationRule,
        TelegramNotificationRule,
    ] = Field(..., discriminator='type')


class OnboardingResponse(BaseModel):
    auth: Optional[Authorization] = None
    bucket: Optional[Bucket] = None
    org: Optional[Organization] = None
    user: Optional[UserResponse] = None


class PostNotificationEndpoint(BaseModel):
    pass


class PostNotificationRule(BaseModel):
    pass


class NotificationEndpoint1(BaseModel):
    id: Optional[str] = None
    kind: Optional[TemplateKind] = None
    new: Optional[NotificationEndpointDiscriminator] = None
    old: Optional[NotificationEndpointDiscriminator] = None
    stateStatus: Optional[str] = None
    templateMetaName: Optional[str] = None


class NotificationEndpoint2(BaseModel):
    envReferences: Optional[TemplateEnvReferences] = None
    kind: Optional[TemplateKind] = None
    labelAssociations: Optional[List[TemplateSummaryLabel]] = None
    templateMetaName: Optional[str] = None


class ThresholdCheck(CheckBase):
    every: Optional[str] = Field(None, description='Check repetition interval.')
    offset: Optional[str] = Field(
        None,
        description='Duration to delay after the schedule, before executing check.',
    )
    statusMessageTemplate: Optional[str] = Field(
        None, description='The template used to generate and write a status message.'
    )
    tags: Optional[List[Tag]] = Field(
        None, description='List of tags to write to each status.'
    )
    thresholds: Optional[List[Threshold]] = None
    type: Literal['threshold']


class XYViewProperties(BaseModel):
    axes: Axes
    colors: List[DashboardColor] = Field(
        ..., description='Colors define color encoding of data into a visualization'
    )
    generateXAxisTicks: Optional[List[str]] = None
    generateYAxisTicks: Optional[List[str]] = None
    geom: XYGeom
    hoverDimension: Optional[HoverDimension] = None
    legendColorizeRows: Optional[bool] = None
    legendHide: Optional[bool] = None
    legendOpacity: Optional[float] = None
    legendOrientationThreshold: Optional[int] = None
    note: str
    position: Position
    queries: List[DashboardQuery]
    shadeBelow: Optional[bool] = None
    shape: Shape
    showNoteWhenEmpty: bool = Field(
        ..., description='If true, will display note when empty'
    )
    staticLegend: Optional[StaticLegend] = None
    timeFormat: Optional[str] = None
    type: Type37
    xColumn: Optional[str] = None
    xTickStart: Optional[float] = None
    xTickStep: Optional[float] = None
    xTotalTicks: Optional[int] = None
    yColumn: Optional[str] = None
    yTickStart: Optional[float] = None
    yTickStep: Optional[float] = None
    yTotalTicks: Optional[int] = None


class CheckDiscriminator(RootModel[Union[DeadmanCheck, ThresholdCheck, CustomCheck]]):
    root: Union[DeadmanCheck, ThresholdCheck, CustomCheck] = Field(
        ..., discriminator='type'
    )


class NotificationEndpoint(BaseModel):
    pass


class NotificationEndpoints(BaseModel):
    links: Optional[Links] = None
    notificationEndpoints: Optional[List[NotificationEndpoint]] = None


class NotificationRule(BaseModel):
    pass


class NotificationRules(BaseModel):
    links: Optional[Links] = None
    notificationRules: Optional[List[NotificationRule]] = None


class PostCheck(BaseModel):
    pass


class Check1(BaseModel):
    id: Optional[str] = None
    kind: Optional[TemplateKind] = None
    new: Optional[CheckDiscriminator] = None
    old: Optional[CheckDiscriminator] = None
    stateStatus: Optional[str] = None
    templateMetaName: Optional[str] = None


class Check2(BaseModel):
    envReferences: Optional[TemplateEnvReferences] = None
    kind: Optional[TemplateKind] = None
    labelAssociations: Optional[List[TemplateSummaryLabel]] = None
    templateMetaName: Optional[str] = None


class Check(BaseModel):
    pass


class CheckViewProperties(BaseModel):
    check: Optional[Check] = None
    checkID: str
    colors: List[DashboardColor] = Field(
        ..., description='Colors define color encoding of data into a visualization'
    )
    legendColorizeRows: Optional[bool] = None
    legendHide: Optional[bool] = None
    legendOpacity: Optional[float] = None
    legendOrientationThreshold: Optional[int] = None
    queries: List[DashboardQuery]
    shape: Shape
    type: Type2


class Checks(BaseModel):
    checks: Optional[List[Check]] = None
    links: Optional[Links] = None


class ViewProperties(
    RootModel[
        Union[
            LinePlusSingleStatProperties,
            XYViewProperties,
            SingleStatViewProperties,
            HistogramViewProperties,
            GaugeViewProperties,
            TableViewProperties,
            MarkdownViewProperties,
            CheckViewProperties,
            ScatterViewProperties,
            HeatmapViewProperties,
            MosaicViewProperties,
            BandViewProperties,
            GeoViewProperties,
        ]
    ]
):
    root: Union[
        LinePlusSingleStatProperties,
        XYViewProperties,
        SingleStatViewProperties,
        HistogramViewProperties,
        GaugeViewProperties,
        TableViewProperties,
        MarkdownViewProperties,
        CheckViewProperties,
        ScatterViewProperties,
        HeatmapViewProperties,
        MosaicViewProperties,
        BandViewProperties,
        GeoViewProperties,
    ]


class CellWithViewProperties(Cell):
    name: Optional[str] = None
    properties: Optional[ViewProperties] = None


class CellsWithViewProperties(RootModel[List[CellWithViewProperties]]):
    root: List[CellWithViewProperties]


class DashboardWithViewProperties(CreateDashboardRequest):
    cells: Optional[CellsWithViewProperties] = None
    id: Optional[str] = None
    labels: Optional[Labels] = None
    links: Optional[Links4] = Field(
        None,
        examples=[
            {
                'cells': '/api/v2/dashboards/1/cells',
                'labels': '/api/v2/dashboards/1/labels',
                'members': '/api/v2/dashboards/1/members',
                'org': '/api/v2/labels/1',
                'owners': '/api/v2/dashboards/1/owners',
                'self': '/api/v2/dashboards/1',
            }
        ],
    )
    meta: Optional[Meta] = None


class TemplateChart(BaseModel):
    height: Optional[int] = None
    properties: Optional[ViewProperties] = None
    width: Optional[int] = None
    xPos: Optional[int] = None
    yPos: Optional[int] = None


class New1(BaseModel):
    charts: Optional[List[TemplateChart]] = None
    description: Optional[str] = None
    name: Optional[str] = None


class Old1(BaseModel):
    charts: Optional[List[TemplateChart]] = None
    description: Optional[str] = None
    name: Optional[str] = None


class Dashboard1(BaseModel):
    id: Optional[str] = None
    kind: Optional[TemplateKind] = None
    new: Optional[New1] = None
    old: Optional[Old1] = None
    stateStatus: Optional[str] = None
    templateMetaName: Optional[str] = None


class Diff(BaseModel):
    buckets: Optional[List[Bucket1]] = None
    checks: Optional[List[Check1]] = None
    dashboards: Optional[List[Dashboard1]] = None
    labelMappings: Optional[List[LabelMapping1]] = None
    labels: Optional[List[Label1]] = None
    notificationEndpoints: Optional[List[NotificationEndpoint1]] = None
    notificationRules: Optional[List[NotificationRule1]] = None
    tasks: Optional[List[Task1]] = None
    telegrafConfigs: Optional[List[TelegrafConfig]] = None
    variables: Optional[List[Variable]] = None


class Dashboard2(BaseModel):
    charts: Optional[List[TemplateChart]] = None
    description: Optional[str] = None
    envReferences: Optional[TemplateEnvReferences] = None
    id: Optional[str] = None
    kind: Optional[TemplateKind] = None
    labelAssociations: Optional[List[TemplateSummaryLabel]] = None
    name: Optional[str] = None
    orgID: Optional[str] = None
    templateMetaName: Optional[str] = None


class Summary(BaseModel):
    buckets: Optional[List[Bucket2]] = None
    checks: Optional[List[Check2]] = None
    dashboards: Optional[List[Dashboard2]] = None
    labelMappings: Optional[List[LabelMapping1]] = None
    labels: Optional[List[TemplateSummaryLabel]] = None
    missingEnvRefs: Optional[List[str]] = None
    missingSecrets: Optional[List[str]] = None
    notificationEndpoints: Optional[List[NotificationEndpoint2]] = None
    notificationRules: Optional[List[NotificationRule2]] = None
    tasks: Optional[List[Task2]] = None
    telegrafConfigs: Optional[List[TelegrafConfig1]] = None
    variables: Optional[List[Variable1]] = None


class TemplateSummary(BaseModel):
    diff: Optional[Diff] = None
    errors: Optional[List[Error2]] = None
    sources: Optional[List[str]] = None
    stackID: Optional[str] = None
    summary: Optional[Summary] = None


class View(BaseModel):
    id: Optional[str] = None
    links: Optional[Links24] = None
    name: str
    properties: ViewProperties


class Views(BaseModel):
    links: Optional[Links24] = None
    views: Optional[List[View]] = None


class DashboardsPostResponse(RootModel[Union[Dashboard, DashboardWithViewProperties]]):
    root: Union[Dashboard, DashboardWithViewProperties]


class DashboardsDashboardIDGetResponse(
    RootModel[Union[Dashboard, DashboardWithViewProperties]]
):
    root: Union[Dashboard, DashboardWithViewProperties]


class DashboardsDashboardIDPatchRequest(BaseModel):
    cells: Optional[CellWithViewProperties] = Field(
        None,
        description='optional, when provided will replace all existing cells with the cells provided',
    )
    description: Optional[str] = Field(
        None, description='optional, when provided will replace the description'
    )
    name: Optional[str] = Field(
        None, description='optional, when provided will replace the name'
    )


class ASTResponse(BaseModel):
    ast: Optional[Package] = None


class ArrayExpression(BaseModel):
    elements: Optional[List[Expression]] = Field(
        None, description='Elements of the array'
    )
    type: Optional[NodeType] = None


class BinaryExpression(BaseModel):
    left: Optional[Expression] = None
    operator: Optional[str] = None
    right: Optional[Expression] = None
    type: Optional[NodeType] = None


class Block(BaseModel):
    body: Optional[List[Statement]] = Field(None, description='Block body')
    type: Optional[NodeType] = None


class CallExpression(BaseModel):
    arguments: Optional[List[Expression]] = Field(
        None, description='Function arguments'
    )
    callee: Optional[Expression] = None
    type: Optional[NodeType] = None


class ConditionalExpression(BaseModel):
    alternate: Optional[Expression] = None
    consequent: Optional[Expression] = None
    test: Optional[Expression] = None
    type: Optional[NodeType] = None


class DictExpression(BaseModel):
    elements: Optional[List[DictItem]] = Field(
        None, description='Elements of the dictionary'
    )
    type: Optional[NodeType] = None


class DictItem(BaseModel):
    key: Optional[Expression] = None
    type: Optional[NodeType] = None
    val: Optional[Expression] = None


class Expression(
    RootModel[
        Union[
            ArrayExpression,
            DictExpression,
            FunctionExpression,
            BinaryExpression,
            CallExpression,
            ConditionalExpression,
            LogicalExpression,
            MemberExpression,
            IndexExpression,
            ObjectExpression,
            ParenExpression,
            PipeExpression,
            UnaryExpression,
            BooleanLiteral,
            DateTimeLiteral,
            DurationLiteral,
            FloatLiteral,
            IntegerLiteral,
            PipeLiteral,
            RegexpLiteral,
            StringLiteral,
            UnsignedIntegerLiteral,
            Identifier,
        ]
    ]
):
    root: Union[
        ArrayExpression,
        DictExpression,
        FunctionExpression,
        BinaryExpression,
        CallExpression,
        ConditionalExpression,
        LogicalExpression,
        MemberExpression,
        IndexExpression,
        ObjectExpression,
        ParenExpression,
        PipeExpression,
        UnaryExpression,
        BooleanLiteral,
        DateTimeLiteral,
        DurationLiteral,
        FloatLiteral,
        IntegerLiteral,
        PipeLiteral,
        RegexpLiteral,
        StringLiteral,
        UnsignedIntegerLiteral,
        Identifier,
    ]


class ExpressionStatement(BaseModel):
    expression: Optional[Expression] = None
    type: Optional[NodeType] = None


class File(BaseModel):
    body: Optional[List[Statement]] = Field(None, description='List of Flux statements')
    imports: Optional[List[ImportDeclaration]] = Field(
        None, description='A list of package imports'
    )
    name: Optional[str] = Field(None, description='The name of the file.')
    package: Optional[PackageClause] = None
    type: Optional[NodeType] = None


class FunctionExpression(BaseModel):
    body: Optional[Node] = None
    params: Optional[List[Property]] = Field(None, description='Function parameters')
    type: Optional[NodeType] = None


class IndexExpression(BaseModel):
    array: Optional[Expression] = None
    index: Optional[Expression] = None
    type: Optional[NodeType] = None


class LogicalExpression(BaseModel):
    left: Optional[Expression] = None
    operator: Optional[str] = None
    right: Optional[Expression] = None
    type: Optional[NodeType] = None


class MemberAssignment(BaseModel):
    init: Optional[Expression] = None
    member: Optional[MemberExpression] = None
    type: Optional[NodeType] = None


class MemberExpression(BaseModel):
    object: Optional[Expression] = None
    property: Optional[PropertyKey] = None
    type: Optional[NodeType] = None


class Node(RootModel[Union[Expression, Block]]):
    root: Union[Expression, Block]


class ObjectExpression(BaseModel):
    properties: Optional[List[Property]] = Field(None, description='Object properties')
    type: Optional[NodeType] = None


class OptionStatement(BaseModel):
    assignment: Optional[Union[VariableAssignment, MemberAssignment]] = None
    type: Optional[NodeType] = None


class Package(BaseModel):
    files: Optional[List[File]] = Field(None, description='Package files')
    package: Optional[str] = Field(None, description='Package name')
    path: Optional[str] = Field(None, description='Package import path')
    type: Optional[NodeType] = None


class ParenExpression(BaseModel):
    expression: Optional[Expression] = None
    type: Optional[NodeType] = None


class PipeExpression(BaseModel):
    argument: Optional[Expression] = None
    call: Optional[CallExpression] = None
    type: Optional[NodeType] = None


class Property(BaseModel):
    key: Optional[PropertyKey] = None
    type: Optional[NodeType] = None
    value: Optional[Expression] = None


class Query(BaseModel):
    dialect: Optional[Dialect] = None
    extern: Optional[File] = None
    now: Optional[datetime] = Field(
        None,
        description='Specifies the time that should be reported as "now" in the query. Default is the server\'s now time.',
    )
    params: Optional[Dict[str, Any]] = Field(
        None,
        description='Enumeration of key/value pairs that respresent parameters to be injected into query (can only specify either this field or extern and not both)\n',
    )
    query: str = Field(..., description='Query script to execute.')
    type: Optional[Type23] = Field(
        None, description='The type of query. Must be "flux".'
    )


class ReturnStatement(BaseModel):
    argument: Optional[Expression] = None
    type: Optional[NodeType] = None


class Statement(
    RootModel[
        Union[
            BadStatement,
            VariableAssignment,
            MemberAssignment,
            ExpressionStatement,
            ReturnStatement,
            OptionStatement,
            BuiltinStatement,
            TestStatement,
        ]
    ]
):
    root: Union[
        BadStatement,
        VariableAssignment,
        MemberAssignment,
        ExpressionStatement,
        ReturnStatement,
        OptionStatement,
        BuiltinStatement,
        TestStatement,
    ]


class TestStatement(BaseModel):
    assignment: Optional[VariableAssignment] = None
    type: Optional[NodeType] = None


class UnaryExpression(BaseModel):
    argument: Optional[Expression] = None
    operator: Optional[str] = None
    type: Optional[NodeType] = None


class VariableAssignment(BaseModel):
    id: Optional[Identifier] = None
    init: Optional[Expression] = None
    type: Optional[NodeType] = None


class QueryPostRequest(RootModel[Union[Query, InfluxQLQuery]]):
    root: Union[Query, InfluxQLQuery]


FieldModel.model_rebuild()
HealthCheck.model_rebuild()
ASTResponse.model_rebuild()
ArrayExpression.model_rebuild()
BinaryExpression.model_rebuild()
Block.model_rebuild()
CallExpression.model_rebuild()
ConditionalExpression.model_rebuild()
DictExpression.model_rebuild()
DictItem.model_rebuild()
Expression.model_rebuild()
File.model_rebuild()
FunctionExpression.model_rebuild()
MemberAssignment.model_rebuild()
ObjectExpression.model_rebuild()
OptionStatement.model_rebuild()
Statement.model_rebuild()
TestStatement.model_rebuild()
